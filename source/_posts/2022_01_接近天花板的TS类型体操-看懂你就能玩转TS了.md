---
title: "接近天花板的TS类型体操, 看懂你就能玩转TS了"
date: 2022-01-28 16:06:53
category:
  - 技术
  - 分享
tags:
  - Typescript
---

本文以 [Typescript 4.5](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html) 及以上版本为基础

本文要实现一种类型工具 `type result = Add<"9007199254740991", "9007199254740991">`，能计算出两个数字字符串的和，即 `"18014398509481982"`

## TS 类型体操基本原理

### if 和 else

条件类型，条件类型冒号左边为 `if` 右边为 `else`

```ts
type A = 1
type B = 2
type Example = A extends B ? true : false
```

`type Example = A extends B ? true : false` 中的 `true` 和 `false` 即可以理解成它们分别为 `if` 分支和 `else` 分支中要写的代码

而 `if` 中的条件即为 `A extends B`，`A` 是否可以赋值给 `B`

要实现 `else if` 则需要多个这样的条件类型进行组合

### 模式匹配

```ts
type A = [1, 2, 3]
type ExampleA = A extends [infer First, ...infer Rest] ? First : never // 1
type B = "123"
type ExampleB = B extends `${infer FirstChar}${infer Rest}` ? FirstChar : never // '1'
```

模式匹配是我们要利用的最有用的 `ts` 特性之一，之后我们要实现的字符串的增删改查和元组的增删改查都要基于它

如果你想知道更多，可以参考这篇文章：[模式匹配-让你 ts 类型体操水平暴增的套路](https://juejin.cn/post/7045536402112512007)

关于条件类型中 `infer` 的官方文档：[Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

### 与或非

基于条件类型可以轻松实现与或非

```ts
// C 意为 Condition，条件
// 与，即 C1，C2 同为真
type And<C1 extends boolean, C2 extends boolean> = C1 extends true
  ? C2 extends true
    ? true
    : false
  : false

// 与，即 C1，C2 有一个为真
type Or<C1 extends boolean, C2 extends boolean> = C1 extends true
  ? true
  : C2 extends true
  ? true
  : false

// 非，即反转 C 的真假状态
type Not<C extends boolean> = C extends true ? false : true
```

`ts` 目前不支持动态个数的泛型参数，因此如果有多个条件

### 判断相等

在 js 的运算操作符中，有 `==` 和 `===`

在 ts 类型系统中，也可以实现类似的判断

```ts
type CheckLeftIsExtendsRight<T extends any, R extends any> = T extends R
  ? true
  : false

type IsEqual<A, B> = (<T>() => T extends A ? 1 : 2) extends <
  T1
>() => T1 extends B ? 1 : 2
  ? true
  : false
```

`CheckLeftIsExtendsRight` 即校验左值是否可赋值给右值，和 `==` 不同的是，`==` 会进行类型转换后进行比较，而条件类型 `Left extends Right ? xxx : xxx` 只会进行结构性兼容的检查

如

```ts
```

`IsEqual` 参考 [github - typescript issue：[Feature request]type level equal operator](https://github.com/microsoft/TypeScript/issues/27024#issuecomment-510924206)

### toString

```ts
type CanStringified = string | number | bigint | boolean | null | undefined
/**
 * @exports
 * 将支持的类型转化为字符串
 */
type Stringify<T extends CanStringified> = `${T}`
```

### 基本的数学运算

#### 判断正负

在部分场景下，我们可以兼容 number 类型的数字，也可以兼容 string 类型的数字，定义其为 `NumberLike`

```ts
type NumberLike = number | `${number}`
```

判断为 0

```ts
/**
 * number类型是否为0
 */
type IsZero<N extends NumberLike> = common.CheckLeftIsExtendsRight<N, 0 | "0">

/**
 * number类型是否大于0
 */
type IsOverZero<N extends NumberLike> = IsZero<N> extends true
  ? false
  : common.CheckLeftIsExtendsRight<
      string.Stringify<N> extends `${"-"}${infer Rest}` ? Rest : never,
      never
    >

/**
 * number类型是否小于0
 */
type IsLessZero<N extends NumberLike> = common.Not<IsOverZero<N>>
```

#### 比较大小

```ts
type CompareHelper<
  N1 extends number,
  N2 extends number,
  A1 extends unknown[] = array.GetTuple<N1>,
  A2 extends unknown[] = array.GetTuple<N2>
> = IsNotEqual<N1, N2, true> extends true
  ? common.Or<IsZero<A1["length"]>, IsZero<A2["length"]>> extends true
    ? IsZero<A1["length"]> extends true
      ? false
      : true
    : CompareHelper<array.Pop<A1>["length"], array.Pop<A2>["length"]>
  : false

type Compare<N1 extends number, N2 extends number> = CompareHelper<N1, N2>
```

#### 两数相加

```ts
type IntAddSingleHepler<N1 extends number, N2 extends number> = [
  ...array.GetTuple<N1>,
  ...array.GetTuple<N2>
]["length"]

/**
 * 正整数（和0）加法，A1，A2最大999
 * @see https://juejin.cn/post/7050893279818317854#heading-8
 */
type IntAddSingle<N1 extends number, N2 extends number> = IntAddSingleHepler<
  N1,
  N2
> extends number
  ? IntAddSingleHepler<N1, N2>
  : number
```

#### 两数相减

```ts
type IntMinusSingleAbsHelper<
  N1 extends number,
  N2 extends number,
  A1 extends unknown[] = array.GetTuple<N1>,
  A2 extends unknown[] = array.GetTuple<N2>
> = IsNotEqual<N1, N2, true> extends true
  ? common.Or<IsZero<A1["length"]>, IsZero<A2["length"]>> extends true
    ? IsZero<A1["length"]> extends true
      ? A2["length"]
      : A1["length"]
    : IntMinusSingleAbsHelper<array.Pop<A1>["length"], array.Pop<A2>["length"]>
  : 0

type IntMinusSingleAbs<
  N1 extends number,
  N2 extends number
> = IntMinusSingleAbsHelper<N1, N2>
```

> 相关文章推荐
>
> [本文原文](https://yzl.xyz/lin/2022/01/%E6%8E%A5%E8%BF%91%E5%A4%A9%E8%8A%B1%E6%9D%BF%E7%9A%84TS%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D-%E7%9C%8B%E6%87%82%E4%BD%A0%E5%B0%B1%E8%83%BD%E7%8E%A9%E8%BD%ACTS%E4%BA%86/c7c8c77c59d1.html)
> 
> [掘金：TypeScript 类型体操姿势合集<通关总结>--刷完](https://juejin.cn/post/6999280101556748295)
> 
> [掘金：Ts高手篇：22个示例深入讲解Ts最晦涩难懂的高级类型工具](https://juejin.cn/post/6994102811218673700)
> 
> [掘金：来做操吧！深入 TypeScript 高级类型和类型体操](https://juejin.cn/post/7039856272354574372)
> 
> [掘金：模式匹配-让你 ts 类型体操水平暴增的套路](https://juejin.cn/post/7045536402112512007)