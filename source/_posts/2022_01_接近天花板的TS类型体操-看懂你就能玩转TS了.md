---
title: "接近天花板的TS类型体操, 看懂你就能玩转TS了"
date: 2022-01-28 16:06:53
category:
  - 技术
  - 分享
tags:
  - Typescript
---

## TS 类型体操基本原理

### if 和 else

条件类型，条件类型冒号左边为 if 右边为 else

```ts
type A = 1
type B = 2
type Example = A extends B ? true : false
```

### 模式匹配

```ts
type A = [1, 2, 3]
type ExampleA = A extends [infer First, ...infer Rest] ? First : never // 1
type B = "123"
type ExampleB = B extends `${infer FirstChar}${infer Rest}` ? FirstChar : never // '1'
```

### 与或非

基于条件类型可以轻松实现与或非

```ts
type And<C1 extends boolean, C2 extends boolean> = C1 extends true
  ? C2 extends true
    ? true
    : false
  : false

type Or<C1 extends boolean, C2 extends boolean> = C1 extends true
  ? true
  : C2 extends true
  ? true
  : false

type Not<C extends boolean> = C extends true ? false : true
```

### 判断相等

在 js 的运算操作符中，有 `==` 和 `===`

在 ts 类型系统中，也可以实现类似的判断

```ts
type CheckLeftIsExtendsRight<T extends any, R extends any> = T extends R
  ? true
  : false

type IsEqual<A, B> = (<T>() => T extends A ? 1 : 2) extends <
  T1
>() => T1 extends B ? 1 : 2
  ? true
  : false
```

IsEqual 参考 [github - typescript issue](https://github.com/microsoft/TypeScript/issues/27024#issuecomment-510924206)

### toString

```ts
type CanStringified = string | number | bigint | boolean | null | undefined
/**
 * @exports
 * 将支持的类型转化为字符串
 */
type Stringify<T extends CanStringified> = `${T}`
```

### 基本的数学运算

#### 判断正负

在部分场景下，我们可以兼容 number 类型的数字，也可以兼容 string 类型的数字，定义其为 `NumberLike`

```ts
type NumberLike = number | `${number}`
```

判断为 0

```ts
/**
 * number类型是否为0
 */
type IsZero<N extends NumberLike> = common.CheckLeftIsExtendsRight<N, 0 | "0">

/**
 * number类型是否大于0
 */
type IsOverZero<N extends NumberLike> = IsZero<N> extends true
  ? false
  : common.CheckLeftIsExtendsRight<
      string.Stringify<N> extends `${"-"}${infer Rest}` ? Rest : never,
      never
    >

/**
 * number类型是否小于0
 */
type IsLessZero<N extends NumberLike> = common.Not<IsOverZero<N>>
```

#### 比较大小

```ts
type CompareHelper<
  N1 extends number,
  N2 extends number,
  A1 extends unknown[] = array.GetTuple<N1>,
  A2 extends unknown[] = array.GetTuple<N2>
> = IsNotEqual<N1, N2, true> extends true
  ? common.Or<IsZero<A1["length"]>, IsZero<A2["length"]>> extends true
    ? IsZero<A1["length"]> extends true
      ? false
      : true
    : CompareHelper<array.Pop<A1>["length"], array.Pop<A2>["length"]>
  : false

type Compare<N1 extends number, N2 extends number> = CompareHelper<N1, N2>
```

#### 两数相加

```ts
type IntAddSingleHepler<N1 extends number, N2 extends number> = [
  ...array.GetTuple<N1>,
  ...array.GetTuple<N2>
]["length"]

/**
 * 正整数（和0）加法，A1，A2最大999
 * @see https://juejin.cn/post/7050893279818317854#heading-8
 */
type IntAddSingle<N1 extends number, N2 extends number> = IntAddSingleHepler<
  N1,
  N2
> extends number
  ? IntAddSingleHepler<N1, N2>
  : number
```

#### 两数相减

```ts
type IntMinusSingleAbsHelper<
  N1 extends number,
  N2 extends number,
  A1 extends unknown[] = array.GetTuple<N1>,
  A2 extends unknown[] = array.GetTuple<N2>
> = IsNotEqual<N1, N2, true> extends true
  ? common.Or<IsZero<A1["length"]>, IsZero<A2["length"]>> extends true
    ? IsZero<A1["length"]> extends true
      ? A2["length"]
      : A1["length"]
    : IntMinusSingleAbsHelper<array.Pop<A1>["length"], array.Pop<A2>["length"]>
  : 0

type IntMinusSingleAbs<
  N1 extends number,
  N2 extends number
> = IntMinusSingleAbsHelper<N1, N2>
```
