---
title: 从零实现一个 Vue3.0
date: 2021-07-18 20:45:20
category:
  - 技术
  - 分享
tags:
  - Vue
---

## Vue2 和 Vue3 的区别

- 源码采用 `monorepo` 方式进行管理，将模块拆分到 package 目录中
- `Vue3` 采用`ts`开发,增强类型检测。 `Vue2` 则采用`flow`
- `Vue3` 的性能优化，去掉了不常用的 api，支持 tree-shaking, 不使用就不会被打包
- `Vue2` 后期引入 RFC , 使每个版本改动可控 [rfcs](https://github.com/vuejs/rfcs/tree/master/active-rfcs)

- `Vue3` 劫持数据采用 proxy `Vue2` 劫持数据采用`defineProperty`。 `defineProperty`有性能问题和缺陷
- `Vue3` 中对模板编译进行了优化，编译时 生成了 Block tree，可以对子节点的动态节点进行收集，可以减少比较，并且采用了 `patchFlag` 标记动态节点
- `Vue3` 采用 `compositionApi` （组合式）进行组织功能，解决反复横跳，优化复用逻辑 （mixin 带来的数据来源不清晰、命名冲突等）, 相比 `optionsApi` （声明式）类型推断更加方便
- 增加了 `Fragment`、`Teleport`、`Suspense` 组件

## Vue3 架构分析

### `Monorepo` 介绍

`Monorepo` 是管理项目代码的一个方式，指在一个项目仓库（`repo`）中管理多个模块/包(package)

- 一个仓库可维护多个模块，不用到处找仓库
- 方便版本管理和依赖管理，模块之间的引用，调用都非常方便

> 缺点：仓库体积会变大。

### 项目结构

- **`reactivity`**：响应式系统
- **`runtime-core`**：与平台无关的运行时核心 (可以创建针对特定平台的运行时 - 自定义渲染器)
- **`runtime-dom`**: 针对浏览器的运行时。包括`DOM API`，属性，事件处理等
- **`runtime-test`**:用于测试
- **`server-renderer`**:用于服务器端渲染
- **`compiler-core`**:与平台无关的编译器核心
- **`compiler-dom`**: 针对浏览器的编译模块
- **`compiler-ssr`**: 针对服务端渲染的编译模块
- **`compiler-sfc`**: 针对单文件解析
- **`size-check`**:用来测试代码体积
- **`template-explorer`**：用于调试编译器输出的开发工具
- **`shared`**：多个包之间共享的内容
- **`vue`**：完整版本,包括运行时和编译器

如图所示

![](vue-next-github.jpg)

```sh
                            +---------------------+
                            |                     |
                            |  @vue/compiler-sfc  |
                            |                     |
                            +-----+--------+------+
                                  |        |
                                  v        v
               +---------------------+    +----------------------+
               |                     |    |                      |
     +-------->|  @vue/compiler-dom  +--->|  @vue/compiler-core  |
     |         |                     |    |                      |
+----+----+    +---------------------+    +----------------------+
|         |
|   vue   |
|         |
+----+----+   +---------------------+    +----------------------+    +-------------------+
    |         |                     |    |                      |    |                   |
    +-------->|  @vue/runtime-dom   +--->|  @vue/runtime-core   +--->|  @vue/reactivity  |
              |                     |    |                      |    |                   |
              +---------------------+    +----------------------+    +-------------------+
```

## 从零实现一个 Vue3.0

### 友情链接

- [Vue 2.0 文档](https://cn.vuejs.org/)
- [Vue 3.0 文档](https://v3.cn.vuejs.org/)
- [Vue 2.0 github 仓库地址](https://github.com/vuejs/vue)
- [Vue 3.0 github 仓库地址](https://github.com/vuejs/vue-next)
- [typescript 文档](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html)
- [rollup 文档](http://rollupjs.org/guide/en/)

### 创建项目

1. 创建文件夹，并进入

```shell
mkdir fake-vue
cd fake-vue
```

2. 初始化 git

```shell
git init
```

3. 初始化项目

```shell
yarn init -y
# or
npm init -y
```

4. 安装依赖

| 依赖                        | 用途                   |
| --------------------------- | ---------------------- |
| typescript                  | 支持 typescript        |
| rollup                      | 打包工具               |
| rollup-plugin-typescript2   | rollup 和 ts 的 桥梁   |
| @rollup/plugin-node-resolve | 解析 node 第三方模块   |
| execa                       | 开启子进程方便执行命令 |

```shell
yarn add typescript rollup rollup-plugin-typescript2 @rollup/plugin-node-resolve execa
```

5. 创建 workspace，实现 Monorepo 管理

   关于 workspace 可以参考 [npm 文档](https://docs.npmjs.com/cli/v7/using-npm/workspaces)

   在项目根目录下的 package.json 文件中添加两个属性

```json
{
  "private": true,
  "workspaces": ["packages/*"]
}
```

同时在根目录下创建 packages 文件夹（执行 `mkdir packages` 命令或手动创建）

6. 初始化 ts

```shell
npx tsc --init
```

7. 新建两个子包，目录结构如下

```txt
├─packages
│  ├─reactivity
│  │  ├─dist
│  │  └─src
│  │  │  └─ index.ts
│  └─shared
│     ├─dist
│     └─src
│  │  │  └─ index.ts
```

在其中（`packages/reactivity` 和 `packages/shared`目录）分别执行 `yarn init -y`

在两个目录下的 package.json 中，分别添加自定义的 rollup 编译选项

`packages/reactivity` 该目录存放 VueReactivity 模块的代码

```json
{
  "buildOptions": {
    /* 我们自定义了一个属性叫这个名字，后续会用到 */
    "name": "VueReactivity" /* 构建时可用于创建全局变量名 */,
    "formats": [
      "esm-bundler",
      "cjs",
      "global"
    ] /* ES Modules、CommonJS、script 标签引入 */
  }
}
```

`packages/shared` 该目录存放整个项目（代码仓库）需要引入的公共逻辑、工具方法等

```json
{
  "buildOptions": {
    "name": "shared",
    "formats": ["esm-bundler", "cjs"]
  }
}
```

### 编写构建配置和脚本代码

1. 在项目根目录创建 `scripts` 目录，用于存放 npm 脚本文件，创建 `build.js` 和 `dev.js` 文件，在项目根目录创建 `rollup.config.js`
2. 创建 npm 脚本命令，在项目根目录的 `package.json` 中加入 scripts 属性

```json
{
  "scripts": {
    "build": "node scripts/build.js",
    "dev": "node scripts/dev.js"
  }
}
```

3. 编写 `rollup.config.js` 代码，该文件需要导出 rollup 需要的配置

```js
// Monorepo 方式管理的项目中，会有多个子包，每个包有着不同的打包配置
// 每次通过 rollup 相关命令进行构建时，都会读取 rollup.config.js 文件，同时在该文件中，可以通过 process.env 上的属性，访问到命令传参
// 执行命令 rollup -c --environment TARGET:dirname 进行构建， dirname 为要构建的文件夹名
// 你可以导出一个由构建输出方式的配置组成的数组，具体可参考以下实现

// 首先，我们需要读取到子包的根路径，在 node 中获取路径需要先引入 path 模块
import path from "path";
// 之后读取 packages 目录的绝对路径
const packagesDir = path.resolve(__dirname, "packages");
// 然后读取命令中的 TARGET 参数，并和 packagesDir 进行拼接，拿到即将构建的子包的根路径
const packageDir = path.resolve(packagesDir, process.env.TARGET);
// 之后的操作都是在子包的根路径下进行的，我们可以封装一个函数，用于拼接路径
const resolve = (yourPath) => path.resolve(packageDir, yourPath);
// 前文我们已经在每个子包的 package.json 中配置了 buildOptions，现在需要拿到这个配置
const packageJSON = require(resolve("package.json"));
// 读取 packageJSON 的 buildOptions 属性
const buildOptions = packageJSON.buildOptions;
// 获取 packageDir 这个目录路径的最后一个文件夹的名字
const name = path.basename(packageDir);
// 接下来定义 buildOptions 中 "esm-bundler", "cjs", "global" 和 rollup 配置项中 output 属性的对应关系
const outputMap = {
  "esm-bundler": {
    file: resolve(`dist/${name}.esm-bundler.js`), // 文件输出路径
    format: "es",
  },
  cjs: {
    file: resolve(`dist/${name}.cjs.js`),
    format: "cjs",
  },
  global: {
    file: resolve(`dist/${name}.global.js`),
    format: "iife",
  },
};
// 定义一个 createConfig 用于创建并返回配置
function createConfig(output) {
  output.name = buildOptions.name; // name 在 script 方式引入包的时候，会注入到全局变量里，如 window[name]
  output.sourcemap = true; // 开启 sourcemap
  return {
    input: resolve(`src/index.ts`), // 定义入口文件的路径
    output, // 定义输出配置 file、format、name、sourcemap
    plugins: [
      // 插件配置，可自行查阅 rollup 和插件的相关文档
      ts({
        tsconfig: path.resolve(__dirname, "tsconfig.json"),
      }), // import ts from 'rollup-plugin-typescript2' 文件顶部加，用于解析 ts 插件
      resolvePlugin(), // import resolvePlugin from '@rollup/plugin-node-resolve' 本文件顶部加，用于解析第三方模块
    ],
  };
}

// 导出配置项
export default buildOptions.formats.map((format) =>
  createConfig(outputMap[format])
);
```

4. 编写 `scripts/build.js` 和 `scripts/dev.js` 脚本文件代码

```js
// build.js
// 发布前构建，没有配置代码压缩
const fs = require("fs");
const execa = require("execa"); // 可以打开一个进程

// 找到 packages 目录下的所有文件夹
const dirs = fs
  .readdirSync(require("path").join(__dirname, "../packages"))
  .filter((f) => {
    if (
      !fs
        .statSync(require("path").join(__dirname, `../packages/${f}`))
        .isDirectory()
    ) {
      return false;
    }
    return true;
  });

// 执行单个构建任务
async function build(target) {
  await execa("rollup", ["-c", "--environment", `TARGET:${target}`], {
    stdio: "inherit", // 子进程在父进程输出
  });
}

// 使用 Promise all 执行所有的构建任务
async function runParallel(dirs, iterFn) {
  const result = [];
  for (let item of dirs) {
    result.push(iterFn(item));
  }
  return Promise.all(result);
}

runParallel(dirs, build).then(() => {
  console.log("成功");
});
```

```js
// dev.js
// 开发时使用，我们先开发 reactivity，先写死成这个
const execa = require("execa");
const target = "reactivity";

execa("rollup", ["-wc", "--environment", `TARGET:${target}`], {
  stdio: "inherit",
});
```

之后在 `packages/reactivity/src/index.ts`、 `packages/shared/src/index.ts` 中写一点代码，然后执行 `yarn build`，就可以看到编译产生的 `dist` 目录及其下面的 js 文件了

### VueReactivity 的使用

在实现它之前，我们得先知道它怎么用，能干什么

在项目根目录新建 examples 文件夹，用于开发和调试，切换到 examples 目录下，安装 `@vue/reactivity` 模块（`yarn add @vue/reactivity `）

创建 `vue-reactivity-example.html` 文件，并生成 html5 模板

通过 script 方式引入 `@vue/reactivity` 模块

```html
<script src="node_modules/@vue/reactivity/dist/reactivity.global.js"></script>
<script>
  // ============ example ============
  console.log(VueReactivity);
</script>
```

得到如下对象

![](VueReactivity-log.jpg)

我们首先看这几个该如何使用： `reactive`、`effect`、`readonly`、`shallowReactive`、`shallowReadonly`

> [Vue3 响应式基础 api 文档](https://v3.cn.vuejs.org/api/basic-reactivity.html#reactive) 、[github vue3 reactivity 文档](https://github.com/vuejs/vue-next/tree/master/packages/reactivity)

#### reactive

```html
<script src="node_modules/@vue/reactivity/dist/reactivity.global.js"></script>
<script>
  // ============ example ============
  const { reactive, effect, readonly, shallowReactive, shallowReadonly } =
    VueReactivity;
  const dog = {
    // 一条狗
    name: "husky", // 名字叫 哈士奇
    type: "husky", // 品种也叫 哈士奇
    age: 5, // 已经 5 岁了
    gender: "雄性", // 是条公狗
  };
  // 通过 reactive 包裹后，proxyDog 为 dog 对象的响应式副本
  const proxyDog = reactive(dog);

  console.log(proxyDog);
</script>
```

打印这个 `proxyDog` 得到如下图所示的被代理的对象

![](proxy-dog-example.jpg)

#### readonly

```html
<script src="node_modules/@vue/reactivity/dist/reactivity.global.js"></script>
<script>
  // ============ example ============
  const { reactive, effect, readonly, shallowReactive, shallowReadonly } =
    VueReactivity;
  const dog = {
    // 一条狗
    name: "husky", // 名字叫 哈士奇
    type: "husky", // 品种也叫 哈士奇
    age: 5, // 已经 5 岁了
    gender: "雄性", // 是条公狗
  };
  // 通过 readonly 包裹后，readonlyProxyDog 为 dog 原始对象的只读副本
  const readonlyProxyDog = readonly(dog);

  console.log(readonlyProxyDog);
  readonlyProxyDog.name = "xiao hua"; // 此时修改并不会生效，并且你会看到一条警告，如下所示
  // Set operation on key "name" failed: target is readonly. {name: "husky", type: "husky", age: 5, gender: "雄性"}
</script>
```

#### shallowReactive

shallowReactive 只会对原始对象做一层代理（不执行嵌套对象的深层响应式转换），而 reactive 方法会对原始对象做深层代理

#### shallowReadonly

创建一个 proxy，使其自身的 property 为只读（但不执行嵌套对象的深度只读转换），而 readonly 方法会对原始对象做深层代理，并使每一层的属性都变为只读

#### effect

effect 可以接受一个函数，并立即执行它（或传入 effect 接收的第二个参数使其不立即执行），如果函数体内部访问了被 reactive 方法或 shallowReactive 方法包裹的 proxy 对象中的属性，则将其视为依赖项，当依赖项的值发生变化时，再次执行 effect 中传入的函数

具体可看如下示例

```html
<script src="node_modules/@vue/reactivity/dist/reactivity.global.js"></script>
<script>
  // ============ example ============
  const { reactive, effect, readonly, shallowReactive, shallowReadonly } =
    VueReactivity;
  const dog = {
    name: "husky",
    type: "husky",
    age: 5,
    gender: "雄性",
  };
  const proxyDog = reactive(dog);

  effect(() => {
    console.log(`我给狗狗过${proxyDog.age}岁生日了`);
  });

  const aYearLater = 1000 * 60 * 60 * 24 * 365;

  setTimeout(() => {
    proxyDog.age++;
  }, aYearLater);
  // `我给狗狗过${proxyDog.age}岁生日了` 这段文本会被打印两次，
  // 第一次是立即打印，打印的信息为： 我给狗狗过5岁生日了
  // 第二次是距离上次打印一年后，打印的信息为： 我给狗狗过6岁生日了
</script>
```

### 实现 `reactive`、`readonly`、`shallowReactive`、`shallowReadonly`

1. 首先，我们要明确 index.ts 文件一般用作导出，不写具体的代码逻辑，所以，我们在 `packages/reactivity/src` 目录下创建一个 `reactive.ts` 文件

 <u>packages/reactivity/src/reactive.ts</u>

 在其中创建四个函数并导出

```ts
export function reactive(target: object) {}

export function shallowReactive(target: object) {}

export function readonly(target: object) {}

export function shallowReadonly(target: object) {}
```

<u>packages/reactivity/src/index.ts</u>

```ts
// 外界无需关注 reactive 的实现，只需要通过 index.ts 导入自己需要的函数
export {
  reactive,
  shallowReactive,
  readonly,
  shallowReadonly,
} from "./reactive.ts";
```

2. 这四个函数都是需要传入一个原始对象，然后返回一个被代理的对象，因此我们可以定义另一个函数来统一处理这部分逻辑

<u>packages/reactivity/src/reactive.ts</u>

```ts
/**
 * 创建响应式对象
 * @param target 传入的原始对象
 * @param isReadonly 是否只读
 * @param baseHandler 代理的处理方法的对象(ProxyHandler 为 ts 声明文件中自带)
 * @returns 代理后的对象
 */
function createReactiveObject(
  target: object,
  isReadonly: boolean,
  baseHandler: ProxyHandler<any>
) {}
```

如果你对上面代码中的 baseHandler 不理解，可以去了解一下 `Proxy` 的使用，MDN 的这篇文档说的很详细 [Proxy MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)，如果你有一定的了解，可以继续往下看

3. `createReactiveObject` 的实现也就是创建代理的过程，事实上，我们只需要参数 `target` 和参数 `baseHandler` 就可以实现代理

```ts
// ============ example ============
const proxy = new Proxy(target, baseHandler);
```

现在，`target` 是由用户传入的，我们只需要验证它是不是对象就可以了，如果不是对象，直接返回它本身，否则返回一个原始对象的代理，`baseHandler` 应该由我们自己定义，`isReadonly` 主要用于区分 `reactive` 、`shallowReactive` 和 `readonly` 、`shallowReadonly`，目前用不到，之后再看，那么 `createReactiveObject` 暂时这样实现：

<u>packages/reactivity/src/reactive.ts</u>

```ts
function createReactiveObject(
  target: object,
  isReadonly: boolean,
  baseHandler: ProxyHandler<any>
) {
  if (typeof target !== "object" || target === null) return target;

  const proxy = new Proxy(target, baseHandler);
  return proxy;
}
```

你有没有发现像 `typeof target !== 'object' || target === null` 这样的判断以后可能会用到很多次，而且在其他模块中也同样适用，还记得我们创建了 `shared` 模块吗，我们可以把这段逻辑写到 `shared` 模块中

<u>packages/shared/src/index.ts</u>

```ts
export function isObject(val: unknown): val is Record<any, any> {
  return typeof val === "object" && val !== null;
}
```

> ts 中工具类型 Record 的用法可以参考我的这篇 [文章：深入浅出 TS 的 Utility Types](https://yzl.xyz/lin/2021/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BATS%E7%9A%84Utility-Types/0b5a4c408b0d.html#Record)

在 tsconfig.ts 文件中需要增加如下配置

```json
{
  /* Module Resolution Options */
  "moduleResolution": "node" /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */,
  "baseUrl": "./" /* Base directory to resolve non-absolute module names. */,
  "paths": {
    "shared": ["packages/shared/src"]
  }
}
```

之后，可以在 <u>packages/reactivity/src/reactive.ts</u> 这样导入 刚定义好的 `isObject`

```ts
import { isObject } from "shared";
```

如果你想带 scope 导入 shared 模块，那上述配置的 paths 要这样写

```json
{
  "paths": {
    "@vue/*": ["packages/*/src"]
  }
}
```

然后 import 的路径写成这样

```ts
import { isObject } from '@vue/shared'
```

之后改写 `createReactiveObject` 方法

<u>packages/reactivity/src/reactive.ts</u>

```ts
import { isObject } from "shared";

function createReactiveObject(
  target: object,
  isReadonly: boolean,
  baseHandler: ProxyHandler<any>
) {
  if (!isObject(val)) return target;

  const proxy = new Proxy(target, baseHandler);
  return proxy;
}
```

再将本章节 `1` 中的四个函数的实现完善一下，同时我们也需要对每一个函数都指定一个 handler 对象

<u>packages/reactivity/src/reactive.ts</u>

```ts
const mutableHandler = {},
      readonlyHanler = {}, 
      shallowReactiveHandler = {}, 
      shallowReadonlyHanler = {}

export function reactive(target: object) {
    return createReactiveObject(target, false, mutableHandler)
}

export function shallowReactive(target: object) {
    return createReactiveObject(target, false, shallowReactiveHandler)
}

export function readonly(target: object) {
    return createReactiveObject(target, false, readonlyHanler)
}

export function shallowReadonly(target: object) {
    return createReactiveObject(target, false, shallowReadonlyHanler)
}
```

由于代理对象会对对象进行劫持，实现的劫持逻辑可能比较复杂，所以我们得为各个 handler 们单独创建一个文件用于实现这部分逻辑

4. 处理 baseHandlers

创建 `packages/reactivity/src/baseHandler.ts` 文件

<u>packages/reactivity/src/baseHandler.ts</u>

```ts
const mutableHandler = {},
      readonlyHanler = {}, 
      shallowReactiveHandler = {}, 
      shallowReadonlyHanler = {}

export {
    mutableHandler,
    readonlyHanler,
    shallowReactiveHandler,
    shallowReadonlyHanler
}
```

<u>packages/reactivity/src/reactive.ts</u>

```ts
// 替换 handler 声明为从 baseHandler 文件导入
import { mutableHandler, readonlyHanler, shallowReactiveHandler, shallowReadonlyHanler } from "./baseHandler"
```

这四个对象现在都需要 get 和 set 属性对传入的 target 原始对象的属性进行劫持，在取值和赋值的时候，执行相应的逻辑

因此，我们需要一个函数来依据不同情况创建对应的 get 和 set 函数逻辑

example

```js
// ============ example ============
const person = {
    name: 'kawayiLinLin'
}
const handler = { // 前文说的 baseHandler 就是这样一个传给 Proxy 构造函数的对象，里面包含一个 get 和 set 方法
    get() { // 可查阅文档了解 Proxy 中的 handler 的 get 方法和 set 方法分别会收到什么参数
        console.log('get 被调用了')
        return Reflect.get(...arguments) // 可查阅文档了解 Reflect 的使用
    },
    set() {
        console.log('set 被调用了')
        return Reflect.set(...arguments)
    }
}

const proxy = new Proxy(person, handler)

console.log(proxy.name) // 先打印 "get 被调用了"，后打印 "kawayiLinLin"
proxy.name = 'notKawayiLinLin' // 打印 "set 被调用了"
```

<u>packages/reactivity/src/baseHandler.ts</u>

```ts
import { readonly, reactive } from './reavtive'
import { isObject } from 'shared'

function createGetter(isReadonly = false, isShallow = false) {
    return function get(target: object, key: string | symbol, receiver: object) {
        // Reflect 一般用于与 Proxy 配合使用，好处，如：它能在赋值失败的情况下返回 false
        const result = Reflect.get(target, key, receiver)
        // isShallow 为 true 时，直接返回取到的值 result
        if (isShallow) return result
        // 否则, 如果 result 是对象，继续做深层的代理
        if (isObject(result)) {
            // 如果是只读情况，则用 readonly 进行处理，否则，用 reactive 进行处理
            isReadonly ? readonly(result) : reactive(result)
        }
        return result
    }
}
```

在[Vue2 的 侦听器 模拟实现](https://yzl.xyz/lin/2021/07/vue2.0-%E4%BE%A6%E5%90%AC%E5%99%A8%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/710d4029c0c9.html)一文中，我们讲到了，vue2在初始化时会进行一次全量递归来使得数据变成深层响应式，这种做法开销比较大，在 Vue3 中，递归进行深层代理，变为了取值时才对下一层进行代理，也可以称为懒递归，如下代码段所示

```ts
// ============ example ============
const obj = {
    a: 1,
    b: {
        c: 1
    }
}

const proxy = reactive(obj)

console.log(proxy.a) // 这里只会代理到第一层

console.log(proxy.b) // 取到 b 时，结果为一个对象，则又会对这个被 get 返回的对象 { c: 1 } 进行代理
```



