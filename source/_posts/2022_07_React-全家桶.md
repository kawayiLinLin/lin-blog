---
title: React 全家桶
date: 2022-07-24 13:59:37
tags:
---

## 起步

脚手架生成的代码入口js文件，稍微修改一下
src/index.js
```js
import React from 'react'
import ReactDOM from 'react-dom/client'

const root = ReactDOM.createRoot(document.getElementBy('root'))
root.render(<h1 children="app" />)
```

jsx 会被 babel 转换成 React.createElement 函数调用，它返回的对象就是虚拟DOM

要禁用React17以上的新版的 jsx 转换，可以在命令前加入环境变量 `start: cross-env DISABLED_NEW_JSX_TRANSFORM=true react-scripts start`，新版 `import jsx from 'jsx'; jsx(xxx)`

## 实现 React.createElement

src/utils.js

```js
import { REACT_TEXT } from './element'
// 为了简化实现，所以加了这个逻辑，源码没有，把普通的数字和字符串包装成元素
export function wrapToVdom(element) {
    return typeof element === 'string' || typeof element === 'number' ? {
        type: REACT_TEXT,
        props: element
    } : element
}
```

src/element.js 元素类型

```js
// react 元素
export const REACT_ELEMENT = Symbol('react.element')
// 
export const REACT_TEXT = Symbol('react.text')
```

src/react.js

```js
import { REACT_ELEMENT } from './element'
import { wrapToVdom } from './utils'

function createElement(type, config, children) {
    let ref // 获取真实dom的
    let key // 用来实现 dom diff 的
    if (config) {
        delete config.__source
        delete config.__self
        ref = config.ref
        delete config.ref
        key = config.key
        delete config.key
    }

    const props = { ...config }
    if (arguments.length > 3) {
        // 如果有多个儿子
        props.children = Array.prototype.slice.call(argument, 2).map(wrapToVdom)
    } else {
        // 如果只有一个儿子
        props.children = mapToVdom(children)
    }
    return {
        $$typeof: REACT_ELEMENT, // 表示这是一个虚拟dom，一个React元素
        type, // 虚拟dom的元素类型
        ref,
        key,
        props // id className style
    }
}


const React = {
    createElement,
}

export default React
```

## 渲染

这里还是使用 `ReactDOM.render(<App />, root)`

React16核心设计思路已经齐了
React17加入了fiber
React18加入concurrent优先级调度并发执行，1718为了优化性能

src/react-dom.js

```js
// 需要把虚拟dom变成真实dom变到容器中
function render(vdom, container) {
    mount(vdom, container)
}

function mount(vdom, container) {
    const newDOM = createDOM(vdom)
    container.appendChild(newDOM)
}

function createDOM(vdom) {
    let { type, props } = vdom
    let dom
    if (type === REACT_TEXT) {
        dom = document.createTextNode(props)
    } else {
        dom = document.createTextNode(type)
    }
    if (props) {
        // 更新属性
        updateProps(dom, {} /* 老属性 */, props /* 新属性 */ )
        // 渲染儿子
        if (typeof props.children === 'object' && props.children.props) {
            // 独生子
            mount(props.children, dom)
        } else if (Array.isArray(props.children)) {
            reconcileChildren(props.children, dom)
        }
    }
    return dom
}

function updateProps(dom, oldProps = {}, newProps = {}) {
    for (let key in newProps) {
        if (key === 'children') continue
        else if (key === 'style') {
            const styleObj = newProps[key]
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr]
            }
        } else if (/^on[A-Z].*/.test(key)) {
            dom[key.toLowerCase()] = newProps[key]
        } else {
            dom[key] = newProps[key]
        }
    }

    for (let key in oldProps) {
        if (!newProps.hasOwnProperty(key)) {
            dom[key] = null
        }
    }
}

// 遍历子元素然后渲染
function reconcileChildren(children, parentDOM) {
    for (let i < 0; i < children.length; i++) {
        mount(children[i], parentDOM)
    }
}

const ReactDOM = {
    render
}

export default ReactDOM
```

## 组件

将UI分离成独立的、可复用的组件，概念上类似于js函数


函数组件：
1. 接收一个props对象并返回一个React元素的函数
2. 名称以大写字符开头
3. 先定义再使用
4. 函数组件的返回值有且只能有一个根元素
5. React元素的类型可以是字符串，一个 div，或者一个函数组件类型
6. 可以给函数组件传递属性，最终会传递给props组件对象

src/react-dom.js

```js
function createDOM(vdom) {
    if (type === REACT_TEXT) {
        // ...
    } else if (typeof type === 'function') {
        return mountFunctionComponent(vdom)
    }
}

function mountFunctionComponent(vdom) {
    const { type, props } = vdom
    const renderVdom = type(props)

    return createDOM(renderVdom)
}
```

类组件：
1. 根据属性创建类的实例，并调用实例的render方法返回React元素

src/react.js

```js
import { Component } from './Component'

export { Component }
```

src/component

```js
export class Component {
    static isReactComponent = true
    constructor(props) {
        this.props = props
    }
}
```

src/react-dom.js

```js
function createDOM(vdom) {
    if (type === REACT_TEXT) {
        // ...
    } else if (typeof type === 'function') {
        if (type.isReactComponent) return mountClassComponent(vdom)
        return mountFunctionComponent(vdom)
    }
}

function mountClassComponent(vdom) {
    const { type, props } = vdom
    const classInstance = new type(props)

    const renderVdom = classInstance.render()

    return createDOM(renderVdom)
}
```

## 类组件的更新

src/component

```js
class Updater {
    constructor(classInstance) {
        this.classInstance = classInstance
        this.pendingStates = []  // 后面要支持批量更新
    }

    addState(partialState) {
        this.pendingStates.push(partialState)
        this.emitUpdate()
    }

    emitUpdate() {
        this.updateComponent()
    }

    updateComponent() {
        const { classInstance, pendingStates } = this
        if (pendingStates.length > 0) { // 有将要进行的更新
            shouldUpdate(classInstance, this.getState())
        }
    }

    getState() {
        const { classInstance, pendingStates } = this
        let { state } = classInstance

        pendingStates.forEach(nextState => {
            state = {
                ...state,
                ...nextState
            }
        })
        pendingStates.length = 0
        return state
    }
}

function shouldUpdate(classInstance, nextState) {
    classInstance.state = nextState
    classInstance.forceUpdate()
}

export class Component {
    static isReactComponent = true
    constructor(props) {
        this.props = props
        this.state = {}
        // 每个类组件的实例都会有一个更新器
        this.updater = new Updater(this)
    }

    setState(partialState) {
        this.updater.addState(partialState)
    }

    forceUpdate() {

    }
}
```

## setState

src/react-dom

```js
function mountClassComponent() {
    const { type, props } = vdom
    const classInstance = new type(props)

    const renderVdom = classInstance.render()
    // 缓存上次生成的虚拟 dom，放在组件实例上
    vdom.classInstance = classInstance
    classInstance.oldRenderVdom = vdom.oldRenderVdom = renderVdom

    return createDOM(renderVdom)
}

function mountFunctionComponent(vdom) {
    const { type, props } = vdom
    const renderVdom = type(props)
    // 缓存
    vdom.oldRenderVdom = renderVdom

    return createDOM(renderVdom)
}

function createDOM(vdom) {
    // ...
    // 缓存真实 dom 到虚拟dom上
    vdom.dom = dom
}

// 基于 虚拟dom找到真实dom
export function findDOM(vdom) {
    if (!vdom) return null
    if (vdom.dom) return vdom.dom
    // 函数组件没有对应真实dom，递归查找
    // vdom.type.isReactComponent 或用如下方式区分函数组件和类组件
    const renderVdom = vdom.classInstance ? vdom.classInstance.oldRenderVdom : vdom.oldRenderVdom
    return findDOM(renderVdom)
}

// 比较虚拟dom，更新真实 dom
export function compareTwoVdom(parentNode, oldVdom, newVdom) {
    const oldDOM = findDOM(oldVdom)
    const newDOM = createDOM(newVdom)
    parentNode.replaceChild(oldDOM, newDOM)
}
```

src/component

```js
import { findDOM } from './react-dom'
export class Component {
    static isReactComponent = true
    constructor(props) {
        this.props = props
        this.state = {}
        // 每个类组件的实例都会有一个更新器
        this.updater = new Updater(this)
    }

    setState(partialState) {
        this.updater.addState(partialState)
    }

    forceUpdate() {
        const oldRenderVdom = this.oldRenderVdom
        const oldDOM = findDOM(oldRenderVdom)
        // 渲染新的虚拟dom
        const newRenderVdom = this.render()
        compareTwoVdom(oldDOM.parentNode, oldRenderVdom, newRenderVdom)
        this.oldRenderVdom = newRenderVdom
    }
}
```

## 合成事件和批量更新

只要是 react 能管理的方法，都是批量的，比如合成事件和生命周期回调中，状态修改和视图更新

## fiber