---
title: React 全家桶
date: 2022-07-24 13:59:37
tags:
---

## 起步

脚手架生成的代码入口js文件，稍微修改一下
src/index.js
```js
import React from 'react'
import ReactDOM from 'react-dom/client'

const root = ReactDOM.createRoot(document.getElementBy('root'))
root.render(<h1 children="app" />)
```

jsx 会被 babel 转换成 React.createElement 函数调用，它返回的对象就是虚拟DOM

要禁用React17以上的新版的 jsx 转换，可以在命令前加入环境变量 `start: cross-env DISABLED_NEW_JSX_TRANSFORM=true react-scripts start`，新版 `import jsx from 'jsx'; jsx(xxx)`

## 实现 React.createElement

src/utils.js

```js
import { REACT_TEXT } from './element'
// 为了简化实现，所以加了这个逻辑，源码没有，把普通的数字和字符串包装成元素
export function wrapToVdom(element) {
    return typeof element === 'string' || typeof element === 'number' ? {
        type: REACT_TEXT,
        props: element
    } : element
}
```

src/element.js 元素类型

```js
// react 元素
export const REACT_ELEMENT = Symbol('react.element')
// 
export const REACT_TEXT = Symbol('react.text')
```

src/react.js

```js
import { REACT_ELEMENT } from './element'
import { wrapToVdom } from './utils'

function createElement(type, config, children) {
    let ref // 获取真实dom的
    let key // 用来实现 dom diff 的
    if (config) {
        delete config.__source
        delete config.__self
        ref = config.ref
        delete config.ref
        key = config.key
        delete config.key
    }

    const props = { ...config }
    if (arguments.length > 3) {
        // 如果有多个儿子
        props.children = Array.prototype.slice.call(argument, 2).map(wrapToVdom)
    } else {
        // 如果只有一个儿子
        props.children = mapToVdom(children)
    }
    return {
        $$typeof: REACT_ELEMENT, // 表示这是一个虚拟dom，一个React元素
        type, // 虚拟dom的元素类型
        ref,
        key,
        props // id className style
    }
}


const React = {
    createElement,
}

export default React
```

## 渲染

这里还是使用 `ReactDOM.render(<App />, root)`

React16核心设计思路已经齐了
React17加入了fiber
React18加入concurrent优先级调度并发执行，1718为了优化性能

<!-- more -->

src/react-dom.js

```js
// 需要把虚拟dom变成真实dom变到容器中
function render(vdom, container) {
    mount(vdom, container)
}

function mount(vdom, container) {
    const newDOM = createDOM(vdom)
    container.appendChild(newDOM)
}

function createDOM(vdom) {
    let { type, props } = vdom
    let dom
    if (type === REACT_TEXT) {
        dom = document.createTextNode(props)
    } else {
        dom = document.createTextNode(type)
    }
    if (props) {
        // 更新属性
        updateProps(dom, {} /* 老属性 */, props /* 新属性 */ )
        // 渲染儿子
        if (typeof props.children === 'object' && props.children.props) {
            // 独生子
            mount(props.children, dom)
        } else if (Array.isArray(props.children)) {
            reconcileChildren(props.children, dom)
        }
    }
    return dom
}

function updateProps(dom, oldProps = {}, newProps = {}) {
    for (let key in newProps) {
        if (key === 'children') continue
        else if (key === 'style') {
            const styleObj = newProps[key]
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr]
            }
        } else if (/^on[A-Z].*/.test(key)) {
            dom[key.toLowerCase()] = newProps[key]
        } else {
            dom[key] = newProps[key]
        }
    }

    for (let key in oldProps) {
        if (!newProps.hasOwnProperty(key)) {
            dom[key] = null
        }
    }
}

// 遍历子元素然后渲染
function reconcileChildren(children, parentDOM) {
    for (let i < 0; i < children.length; i++) {
        mount(children[i], parentDOM)
    }
}

const ReactDOM = {
    render
}

export default ReactDOM
```

## 组件

将UI分离成独立的、可复用的组件，概念上类似于js函数


函数组件：
1. 接收一个props对象并返回一个React元素的函数
2. 名称以大写字符开头
3. 先定义再使用
4. 函数组件的返回值有且只能有一个根元素
5. React元素的类型可以是字符串，一个 div，或者一个函数组件类型
6. 可以给函数组件传递属性，最终会传递给props组件对象

src/react-dom.js

```js
function createDOM(vdom) {
    if (type === REACT_TEXT) {
        // ...
    } else if (typeof type === 'function') {
        return mountFunctionComponent(vdom)
    }
}

function mountFunctionComponent(vdom) {
    const { type, props } = vdom
    const renderVdom = type(props)

    return createDOM(renderVdom)
}
```

类组件：
1. 根据属性创建类的实例，并调用实例的render方法返回React元素

src/react.js

```js
import { Component } from './Component'

export { Component }
```

src/Component

```js
export class Component {
    static isReactComponent = true
    constructor(props) {
        this.props = props
    }
}
```

src/react-dom.js

```js
function createDOM(vdom) {
    if (type === REACT_TEXT) {
        // ...
    } else if (typeof type === 'function') {
        if (type.isReactComponent) return mountClassComponent(vdom)
        return mountFunctionComponent(vdom)
    }
}

function mountClassComponent(vdom) {
    const { type, props } = vdom
    const classInstance = new type(props)

    const renderVdom = classInstance.render()

    return createDOM(renderVdom)
}
```

## 类组件的更新

src/Component

```js
class Updater {
    constructor(classInstance) {
        this.classInstance = classInstance
        this.pendingStates = []  // 后面要支持批量更新
    }

    addState(partialState) {
        this.pendingStates.push(partialState)
        this.emitUpdate()
    }

    emitUpdate() {
        this.updateComponent()
    }

    updateComponent() {
        const { classInstance, pendingStates } = this
        if (pendingStates.length > 0) { // 有将要进行的更新
            shouldUpdate(classInstance, this.getState())
        }
    }

    getState() {
        const { classInstance, pendingStates } = this
        let { state } = classInstance

        pendingStates.forEach(nextState => {
            state = {
                ...state,
                ...nextState
            }
        })
        pendingStates.length = 0
        return state
    }
}

function shouldUpdate(classInstance, nextState) {
    classInstance.state = nextState
    classInstance.forceUpdate()
}

export class Component {
    static isReactComponent = true
    constructor(props) {
        this.props = props
        this.state = {}
        // 每个类组件的实例都会有一个更新器
        this.updater = new Updater(this)
    }

    setState(partialState) {
        this.updater.addState(partialState)
    }

    forceUpdate() {

    }
}
```

## setState

src/react-dom

```js
function mountClassComponent() {
    const { type, props } = vdom
    const classInstance = new type(props)

    const renderVdom = classInstance.render()
    // 缓存上次生成的虚拟 dom，放在组件实例上
    vdom.classInstance = classInstance
    classInstance.oldRenderVdom = vdom.oldRenderVdom = renderVdom

    return createDOM(renderVdom)
}

function mountFunctionComponent(vdom) {
    const { type, props } = vdom
    const renderVdom = type(props)
    // 缓存
    vdom.oldRenderVdom = renderVdom

    return createDOM(renderVdom)
}

function createDOM(vdom) {
    // ...
    // 缓存真实 dom 到虚拟dom上
    vdom.dom = dom
}

// 基于 虚拟dom找到真实dom
export function findDOM(vdom) {
    if (!vdom) return null
    if (vdom.dom) return vdom.dom
    // 函数组件没有对应真实dom，递归查找
    // vdom.type.isReactComponent 或用如下方式区分函数组件和类组件
    const renderVdom = vdom.classInstance ? vdom.classInstance.oldRenderVdom : vdom.oldRenderVdom
    return findDOM(renderVdom)
}

// 比较虚拟dom，更新真实 dom
export function compareTwoVdom(parentNode, oldVdom, newVdom) {
    const oldDOM = findDOM(oldVdom)
    const newDOM = createDOM(newVdom)
    parentNode.replaceChild(oldDOM, newDOM)
}
```

src/Component

```js
import { findDOM } from './react-dom'
export class Component {
    static isReactComponent = true
    constructor(props) {
        this.props = props
        this.state = {}
        // 每个类组件的实例都会有一个更新器
        this.updater = new Updater(this)
    }

    setState(partialState) {
        this.updater.addState(partialState)
    }

    forceUpdate() {
        const oldRenderVdom = this.oldRenderVdom
        const oldDOM = findDOM(oldRenderVdom)
        // 渲染新的虚拟dom
        const newRenderVdom = this.render()
        compareTwoVdom(oldDOM.parentNode, oldRenderVdom, newRenderVdom)
        this.oldRenderVdom = newRenderVdom
    }
}
```

## 合成事件和批量更新

只要是 react 能管理的方法，都是批量的，比如合成事件和生命周期回调中，状态修改和视图更新

src/Component

```js
// 更新对列
export let updateQueue = {
    isBatchingUpdate: false, // 是否批量更新，true就是批量，false就是非批量，同步的
    updaters: new Set(),
    batchUpdate: () => {
        updateQueue.isBatchingUpdate = false
        for (let updater of updateQueue) {
            updater.updateComponent()
        }
        updateQueue.updaters.clear()
    }
}

export class Component {
    // ...
    emitUpdate() {
        if (updateQueue.isBatchingUpdate) {
            return updateQueue.updaters.add(this)
        }
        this.updateComponent()
    } 
    // ...
}
```

src/react-dom

```js
// ...
import { addEvent } from './event'

function updateProps(dom, oldProps = {}, newProps = {}) {
    for (let key in newProps) {
        // ...
        if (xxx) {

        } else if (/^on[A-Z].*/.test(key)) {
            addEvent(dom, key.toLowerCase(), newProps[key])
        }
        // ...
    }
}
```

src/event

```js
import { updateQueue } from './Component'

/**
 * 给dom节点绑定事件
 * @param dom 真实的dom 如button
 * @param eventType 事件名 onclick
 * @param handler 原始的事件处理函数
 */
export function addEvent(dom, evnetType, handler) {
    const store = dom.store || (dom.store || {})
    store[eventType] = handler

    if (!document[eventType]) {
        // react 17 绑的是 document，18 绑的是 react root 节点
        document[eventType] = dispatchEvent
    }
}

function dispatchEvent(event) {
    updateQueue.isBatchingUpdate = true

    const { target, type } = event // target 真实dom，type 是 'click'
    const eventType = `on${type}`
    const { store } = target
    const handler = store && store[eventType]
    handler && handler()


    updateQueue.batchUpdate()
}
```

**合成事件**：屏蔽浏览器差异，实现批量更新

src/event

```js
function dispatchEvent(event) {
    updateQueue.isBatchingUpdate = true

    const { target, type } = event // target 真实dom，type 是 'click'
    const eventType = `on${type}`
    // 创建合成事件
    const syntheicEvent = createSyntheicEvent(event)

    // 这里事件绑定被react代理到document，所以模拟事件冒泡
    let currentTarget = target
    while (currentTarget) {
        // currentTarget 在冒泡的每个阶段，currentTarget 不一样，但是 target 都是一样的，点谁就是谁
        syntheicEvent.currentTarget = currentTarget
        const { store } = currentTarget
        const handler = store && store[eventType]
        // 然后把合成事件对象传给事件处理函数
        handler && handler(syntheicEvent)
        // 如果阻止冒泡，则跳出循环
        if (syntheicEvent.isPropagationStopped) {
            break
        }
        currentTarget = currentTarget.parentNode
    }


    updateQueue.batchUpdate()
}


function createSyntheicEvent(nativeEvent) {
    const syntheicEvent = nativeEvent

    for (let key in nativeEvent) {
        const value = nativeEvent[key]
        if (typeof value === 'function') {
            value = value.bind(nativeEvent)
        }
        syntheicEvent[key] = syntheicEvent
    }
    syntheicEvent.nativeEvent = nativeEvent

    syntheicEvent.isDefaultPrevented = false // 是否已经阻止了默认事件
    syntheicEvent.preventDefault = preventDefault
    syntheicEvent.isPropagationStopped = false // 是否已经阻止冒泡
    syntheicEvent.stopPropagation = stopPropegation

    return syntheicEvent
}


function preventDefault() {
    this.isDefaultPrevented = true
    const event = this.nativeEvent
    if (event.preventDefault) {
        event.preventDefault()
    } else {
        event.returnValue = false
    }
}

// 阻止冒泡
function stopPropagation() {
    this.isPropagationStopped = true
    const event = this.nativeEvent
    if (event.stopPropagation) {
        event.stopPropagation()
    } else {
        event.cancelBubble = false
    }
}
```

## ref

访问 dom 节点，或组件

src/element

```js
export const REACT_FORWARD_REF = Symbol('react.forward_ref')
```

src/react

```js
import { REACT_FORWARD_REF } from './element'
function createRef() {
    return { current: null }
}

// 函数组件传递 ref
// 返回一个对象，$$typeof 是 symbol(react.forward_ref)，对象有个 render，是函数组件
function forwardRef(render) {
    return {
        $$typeof: REACT_FORWARD_REF,
        render
    }
}

const React = {
    // ...
    createRef
}

export default React
```

src/react-dom

```js
import { REACT_FORWARD_REF } from './element'

function createDOM(vdom) {
    const { type, /* ..., */ ref } = vdom
    if (type && type.$$typeof === REACT_FORWARD_REF) {
        return mountForwardCompoent(vdom)
    } else if (xxx) {
        // ...
    }
    // ...
    vdom.dom = dom
    if (ref) {
        ref.current = dom
    }
}

function mountClassComponent(vdom) {
    const { /* ..., */ ref } = vdom
    if (ref) {
        ref.current = classInstance
    }
}

function mountForwardCompoent(vdom) {
    const { type, props, ref } = vdom
    const renderVdom = type.render(props, ref)
    vdom.oldRenderVdom = renderVdom
    return createDOM(renderVdom)
}
```

## 组件的生命周期

1. **setup props and state**
2. **mounting**
2.1 componentWillMount
2.2 render
2.3 componentDidMount
3. **updation**
3.1 props
3.1.1 componentWillRecieveProps
3.1.2 shouldComponentUpdate
3.1.2.1 true -> componentWillUpdate
3.1.2.2 false -> x
3.1.3 render
3.1.4 componentDidUpdate
3.2 state
3.2.1 shouldComponentUpdate
3.2.1.1 true -> componentWillUpdate
3.2.1.2 false -> x
3.2.2 render
3.2.3 componentDidUpdate
4. **unmounting**
4.1 componentWillUnmount

src/react-dom

```js
function mountClassComponent(vdom) {
    const { type, props, ref } = vdom
    const classInstance = new type(props)
    vdom.classInstance = classInstance
    if (ref) ref.current = classInstance
    // render 前 willmount
    if (classInstance.componentWillMount) {
        classInstance.componentWillMount()
    }
    const renderVdom = classInstance.render()
    classInstance.oldRenderVdom = renderVdom
    const dom = createDOM(renderVdom)
    // render 后组件挂载 did mount
    if (classInstance.componentDidMount) {
        classInstance.componentDidMount()
    }
    return dom
}
```

```js
function shouldUpdate(classInstance, nextProps, nextState) {
    let willUpdate = true
    if (classInstance.shouldComponentUpdate && !(classInstance.shouldComponentUpdate(nextProps, nextState))) {
        willUpdate = false
    }
    if (willUpdate && classInstance.willComponentUpdate) {
        classInstance.willComponentUpdate()
    }
    classInstance.state = nextState
    if (willUpdate) {
        classInstance.forceUpdate()
    }
}

class Component {
    //...
    forceUpdate() {
        const oldRenderVdom = this.oldRenderVdom
        const oldDOM = findDOM(oldRenderVdom)
        const newRenderVdom = this.render()
        compareTwoVdom(oldDOM.parentNode, oldRenderVdom, newRenderVdom)
        this.oldRenderVdom = newRenderVdom
        if (this.componentDidUpdate) {
            this.componentDidUpdate(this.props, this.state)
        }
    }
}
```

为什么 will 的生命周期不安全了？
因为 fiber，在 17 及以前，组件渲染是同步的
18 可以暂停

### DOM Diff

src/react-dom

```js
export function compareTwoVdom(parentNode, oldVdom, newVdom, nextDOM) {
    // 新旧都没有
    if (!oldVdom && !newVdom) {
        return null
    } else if (oldVdom && !newVdom) {
        // 旧的有，新的没有，删除
        unmountVdom(oldVdom)
    } else if (!oldVdom && newVdom) {
        const newDOM = createDOM(newVdom)
        // 此处有问题
        if (nextDOM) {
            parentNode.insertBefore(nextDOM, newDOM)
        } else {
            parentNode.appendChild(newDOM)
        }
    } else if (oldVdom && newVdom && oldVdom.type !== newVdom.type) {
        unmountVdom(oldVdom)
        const newDOM = createDOM(newVdom)
        // 此处有问题
        parentNode.appendChild(newDOM)
    } else {
        // 新旧节点都存在，且类型一样，进行深度的dom diff 过程
        updateElement(oldVdom, newVdom)
    }
}

// 把组件对应的真实dom移除掉
function unmountVdom(vdom) {
    const { type, props, ref } = vdom
    const currentDOM = findDOM(vdom)
    if (vdom.classInstance && vdom.classInstance.componentWillUnmount) {
        vdom.classInstance.componentWillUnmount()
    }
    if (ref) {
        ref.current = null
    }
    // 对儿子递归删除
    if (props.children) {
        const children = Array.isArray(props.children) ? props.children : [props.children]
        children.forEach(unmountVdom)
    }
    if (currentDOM) {
        currentDOM.remove()
    }
}

function updateElement(oldVdom, newVdom) {
    if (oldVdom.type === REACT_TEXT) {
        // 新老节点都是文本节点
        const currentDOM = newVdom.dom = findDOM(oldVdom)

        if (oldVdom.props !== newVdom.props) {
            // 文本不一样
            currentDOM.textContent = newVdom.props
        }
    } else if (oldVdom.type === 'string') {
        // 原生节点
        const currentDOM = newVdom.dom = findDOM(oldVdom)
        updateProps(currentDOM, oldVdom.props, newVdom.props)
        updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children)
    } else if (typeof oldVdom.type === 'function') {
        // 类组件和函数组件
        if (oldVdom.type.isReactCompoent) {
            // 类组件
            updateClassComponent(oldVdom, newVdom)
        } else {
            updateFunctionComponent(oldVdom, newVdom)
        }
    }
}


function updateChildren(parentDOM, oldVChildren, newVChildren) {
    oldVChildren = Array.isArray(oldVChildren) ? oldVChildren : [oldVChildren]
    newVChildren = Array.isArray(newVChildren) ? newVChildren : [newVChildrens]
    const max = Math.max(oldVChildren.length, newVChildren.length)

    for (let i = 0; i < max; i ++) {
        // 找到它的后一个 dom，然后把自己放到它前面
        const nextVdom = oldVChildren.find((item, index) => index > i && item && findDOM(item))
        compareTwoVdom(parentDOM, oldVChildren[i], newVChildren[i], nextVdom && nextVdom.dom)
    }
}

function updateClassComponent(oldVdom, newVdom) {
    const classInstance = newVdom.classInstance = oldVdom.classInstance
    if (classInstance.componentWillReceiveProps) {
        classInstance.componentWillReceiveProps(newVdom.props)
    }
    classInstance.updater.emitUpdate(newVdom.props)
}

function updateFunctionComponent(oldVdom, newVdom) {
    const currentDOM = findDOM(oldVdom)
    if (!currentDOM) return
    const parentDOM = currentDOM.parentNode
    const { type, props } = newVdom
    const newRenderVdom = type(props)
    compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, newRenderVdom)
    newVdom.oldRenderVdom = newRenderVdom
}
```

src/Component

```js
class Updater {
    emitUpdate(nextProps) {
        this.nextProps = nextProps
        if (updateQueue.isBatchingUpdate) {
            updateQueue.updaters.add(this)
        } else {
            this.updateComponent()
        }
    }

    updateComponent() {
        const { nextProps, pendingState } = this
        if (nextProps || pendingState.length > 0) {
            shouldUpdate(classInstance, nextProps, this.getState())
        }
    }
}

function shouldUpdate(classInstance, nextProps, nextState) {
    let willUpdate = true
    if (classInstance.shouldComponentUpdate && !(classInstance.shouldComponentUpdate())) {
        willUpdate = false
    }
    if (willUpdate && classInstance.componentWillUpdate) {
        classInstance.componentWillUpdate()
    }
    if (nextProps) {
        classInstance.props = nextProps
    }
    classInstance.state = nextState
    if (willUpdate) {
        classInstance.forceUpdate()
    }
}
```

## DOM DIFF 优化

+ 只会对同级进行对比，跨层级移动不会复用
+ 不同类型的元素会产生不同的结构，销毁老结构，创建新结构
+ 可以通过key标识元素的移动

![](dom-diff.png)

+ 将老的节点缓存在映射表中
+ 遍历新的节点，与老的节点进行对比
+ 如果匹配的到同样的老节点，就将 lastPlacedIndex 与 oldIndex 进行对比，然后将 lastPlacedIndex 置为大的那个
+ 如果 oldIndex 大于等于 lastPlacedIndex，则只做更新操作
+ 如果 oldIndex 小于 lastPlacedIndex，则做移动并更新操作
+ 映射表中没有对应的新节点，则删除该节点

> old 1 2 3 4 5
> new 5 1 2 3 4
> 缺点：这种情况，5对比完了以后lastPlacedIndex变成了4，比旧节点中1234的索引都大，最后会移动1234，性能较差

src/react-dom

```js
function updateChildren(parentDOM, oldVChildren, newVChildren) {
    oldVChildren = (Array.isArray(oldVChildren) ? oldVChildren : [oldVChildren]).filter(Boolean)
    newVChildren = (Array.isArray(newVChildren) ? newVChildren : [newVChildrens]).filter(Boolean)
    let lastPlacedIndex = -1 // 上一个不需要移动的老节点的挂载索引
    let keyedOldMap = {}
    oldVChildren.forEach((oldVChild, i) => {
        const oldKey = oldVChild && oldVChild.key ? oldVChild.key : index
        keyedOldMap[oldKey] = oldChild
    })
    const patch = []
    newVChildren.forEach((newVChild, i) => {
        newVChild && (newVChild.mountIndex = index) // 置为新的索引，下次更新 diff 用这个 index 了
        const newKey = newVChild.key ? newVChild.key : i
        const oldVChild = keyedOldMap[newKey]
        if (oldVChild) { // 找到了此 key 对应的老节点
            updateElement(oldVChild, newVChild)
            if (oldVChild.mountIndex < lastPlacedIndex) { // 要移动
                patch.push({
                    type: 'MOVE',
                    oldVChild,
                    newVChild,
                    mountIndex: i // 新的挂载索引
                })
            }
            delete keyedOldMap[newKey]
            lastPlacedIndex = Math.max(lastPlacedIndex, oldVChild.mountIndex)
        } else {
            // 没有找到对应的旧节点，就插入操作
            patch.push({
                type: 'PLACEMENT', // 插入
                newVChild,
                mountIndex: i
            })
        }
    })
    const moveVChild = patch.filter(action => action.type === 'MOVE').map(action => action.oldVChild)
    // 没有复用到的老节点
    // ABCDEF
    Object.value(oldKeyedMap).concat(moveVChild).forEach(oldVChild => {
        const currentDOM = findDOM(oldVChild)
        currentDOM.remove()
    })
    // ABCE
    patch.forEach(action => {
        const { type, oldVChild, newVChild, mountIndex } = action
        const childNodes = parentDOM.childNodes // [ABCE]
        if (type === 'PLACEMENT') { // 插入节点
            const newDOM = createDOM(newVChild)
            const childNode = childNodes[mountIndex] // 找一下这个索引位置是否已经有真实dom了
            if (childNode) {
                parentDOM.insertBefore(newDOM, childNode)
            } else{
                parentDOM.appendChild(newDOM)
            }
        } else if (type === 'MOVE') {
            // 移动，之前已经删掉了，但是 dom 对象还在，直接复用
            const oldDOM = findDOM(oldVChild)
            const childNode = childNodes[mountIndex] // 找一下这个索引位置是否已经有真实dom了
            if (childNode) {
                parentDOM.insertBefore(oldDOM, childNode)
            } else{
                parentDOM.appendChild(oldDOM)
            }
        }
    })
}

function reconcileChildren(children, parentDOM) {
    for (let i = 0; i < children.length; i ++) {
        children[i].mountIndex = i; // 将挂载索引加到孩子上
        mount(children[i], parentDOM)
    }
}

function createDOM() {
    // ...
    if (props) {
        // ...
        if (typeof props.children === 'object' && props.children.type) {
            props.children.mountIndex = 0
            mount(props.children, dom)
        }
    } 
    // ...
}
```

## Fragment

src/element

```js
export const REACT_FRAGMENT = Symbol('react.fragment')
```

src/react

```js
import { REACT_FRAGMENT } from './element'
const React = {
    Fragment: REACT_FRAGMENT
}

export default React
```

src/react-dom

```js
import { REACT_FRAGMENT } from './element'

function createDOM(vdom) {
    const { type, props, ref } = vdom
    let dom
    if (type === REACT_FRAGMENT) {
        dom = document.createDocumentFragment()
    }
    // if -> else if...
}


function updateElement(oldVdom, newVdom) {
    if (oldVdom.type === REACT_FRAGMENT) {
        const currentDOM = newVdom.dom = findDOM(oldVdom)
        updateChildren(currentDOM, oldVdom.props.children, newVdom.props.children)
    }
    // if -> else if...
}
```

## 新的生命周期

static getDerivedStateFromProps 将传入的属性映射到状态上

getSnapshotBeforeUpdate 在组件将要更新前触发，返回一个值，然后传给 componentDidUpdate 的第三个参数，比如在更新前获取 dom 的各种属性的值，然后更新后进行对比

旧的 will 生命周期除了 componentWillUnmount 都被删掉了

其他几个都可能执行多次，因为 react 可能 暂停、中止、重启组件的挂载和更新

src/Component

```js
class Component {
    forceUpdate() {
        const oldRenderVdom = this.oldRenderVdom
        const oldDOM = findDOM(oldRenderVdom)
        if (this.constructor.getDerivedStateFromProps) {
            const newState = this.constructor.getDerivedStateFromProps(this.props, this.state)
            if (newState) {
                this.state = {
                    ...this.state,
                    ...newState
                }
            }
        }
        // 渲染新的虚拟dom
        const newRenderVdom = this.render()
        // 快照
        const snapShot = this.getSnapshotBeforeUpdate && this.getSnapshotBeforeUpdate()
        compareTwoVdom(oldDOM.parentNode, oldRenderVdom, newRenderVdom)
        this.oldRenderVdom = newRenderVdom
        if (this.componentDidUpdate) {
            this.componentDidUpdate(this.props, this.state, snapShot)
        }
    }
}
```

## context

src/element

```js
export const REACT_CONTEXT = Symbol('react.context')

export const REACT_PROVIDER = Symbol('react.provider')
```

src/react

```js
import { REACT_CONTEXT, REACT_PROVIDER } from './element'

function createContext() {
    const context = {
        $$typeof: REACT_CONTEXT,
        _currentValue: undefined
    }
    context.Provider = {
        $$typeof: REACT_PROVIDER,
        _context: context
    }
    context.Consumer = {
        $$typeof: REACT_CONTEXT,
        _context: context
    }
    return context
}
const React = {
    createContext
}

export default React
```

src/react-dom

```js
import { REACT_CONTEXT, REACT_PROVIDER } from './element'

function createDOM(vdom) {
    const { type, props, ref } = vdom
    let dom
    if (type && type.$$typeof === REACT_PROVIDER) {
        return mountProviderComponent(vdom)
    } else if (type && type.$$typeof === REACT_CONTEXT) (
        return mountContextComponent()
    )
    // else if ...
}

// 渲染 provider 就是渲染它儿子，并给 value 赋值（把 value 传给 currentValue）
function mountProviderComponent(vdom) {
    const { type, props, ref } = vdom
    const context = type._context
    context._currentValue = props.value
    const renderVdom = props.children
    vdom.oldRenderVdom = renderVdom
    return createDOM(renderVdom)
}

// 渲染 consumer 组件，调用儿子函数，然后传值
function mountContextComponent(vdom) {
    const { type, props, ref } = vdom
    const context = type._context
    const renderVdom = props.children(context._currentValue)
    vdom.oldRenderVdom = renderVdom
    return createDOM(renderVdom)
}

// 处理初次渲染 static contextType -> this.context 的转换
function mountClassComponent(vdom) {
    const { type, props, ref } = vdom
    const classInstance = new type(props)
    if (type.contextType) {
        classInstance.context = type.contextType._currentValue
    }
    // ...
}
```

src/Component

```js
import { REACT_CONTEXT, REACT_PROVIDER } from './element'

class Component {
    forceUpdate() {
        const oldRenderVdom = this.oldRenderVdom
        const oldDOM = findDOM(oldRenderVdom)
        if (this.constructor.contextType) {
            this.context = this.constructor.contextType._currentValue
        }
    }
}

// 更新的时候处理 contextType
function updateElement(oldVdom, newVdom) {
    if (oldVdom.type.$$typeof === REACT_CONTEXT) {
        updateContextComponent(oldVdom, newVdom)
    } else if (oldVdom.type.$$typeof === REACT_PROVIDER) {
        updateProviderComponent(oldVdom, newVdom)
    }
    // else if ...
}

function updateContextComponent(oldVdom, newVdom) {
    const currentDOM = findDOM(oldVdom)
    const parentDOM = currentDOM.parentNode
    const { type, props } = newVdom
    const context = type._context
    const renderVdom = props.children(context._currentValue)
    compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom)
    newVdom.oldRenderVdom = renderVdom
}

function updateProviderComponent(oldVdom, newVdom) {
    const currentDOM = findDOM(oldVdom)
    const parentDOM = currentDOM.parentNode
    const { type, props } = newVdom
    const context = type._context
    context._currentValue = props.value
    const renderVdom = props.children
    compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom)
    newVdom.oldRenderVdom = renderVdom
}
```

## 高阶组件

装饰器高阶组件

将 package.json 中的 scripts 命令（react-scripts）都换成 `react-app-rewired`

```shell
npm i react-app-rewired customise-cra @babel/plugin-proposal-decorators -D
```

config.overrides.js

```js
const { override, disableEslint, addDecoratorsLegatory } = require('customise-cra')

module.exports = override(
    disableEslint(),
    addDecoratorsLegatory()
)
```

jsconfig.json

```json
{
    "compilerOptions": {
        "experimentalDecorators": true
    }
}
```

### 反向继承

可用于修改第三方库的逻辑

```js
const contentWrapper = OldComponent => {
    return class NewButton extends OldComponent {
        componentDidMount() {
            super.componentDidMount()
        }
        componetWillMount() {
            super.componentWillMount()
        }
        render() {
            const element = super.render()

            const newProps = {
                ...element.props
            }
            const newChildren = this.props.children
            return React.cloneElement(element, newProps, newChildren)
        }
    }
}
```

src/react


```js
// 拷贝+覆盖孩子(如果有)
function cloneElement(element, newProps, ...newChildren) {
    const children = element.props && element.props.children
    if (newChildren.length > 0) {
        children = newChildren.map(wrapToVdom)
    }

    if (children.length === 1) children = children[0]
    const props = {
        ...element.props,
        ...newProps,
        children
    }
    return {
        ...element,
        props
    }
}

const React = {
    cloneElement
}

export default React
```

## render props

在 props 中传递渲染函数

## 性能优化

+ 属性相同时，不进行渲染 `React.PureComponent`

src/element

```js
const REACT_MEMO = Symbol('react.memo')
```

src/react

```js
import { REACT_MEMO } from './element'

// 浅比较
function shallowEqual(obj1, obj2) {
    if (obj1 === obj2) return true
    if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) return false
    const keys1 = Object.keys(obj1)
    const keys2 = Object.keys(obj2)
    if (keys1.length !== keys2.length) return false
    for (let key of obj1) {
        if (!obj2.hasOwnProperty(key) || obj1[key] !== obj2[key]) {
            return false
        }
    }
    return true
}
class PureComponent extends Component {
    shouldComponentUpdate(nextProps, nextState) {
        return !shallowEqual(nextProps, this.props) || !shallowEqual(nextState, this.state)
    }
}

// type 包装的函数组件，compare 比较方法
function memo(type, compare = shallowEqual) {
    return {
        $$typeof: REACT_MEMO,
        type,
        compare
    }
}

const React = {
    PureComponent,
    memo
}

export default React
```

src/react-dom

```js
import { REACT_MEMO } from './element'

function createDOM(vdom) {
    const { type, props, ref } = vdom
    const dom
    if (type && type.$$typeof === REACT_MEMO) {
        return mountMemoComponent(vdom)
    }
    // else if
}

// 拿到真实dom，然后渲染
function mountMemoComponent(vodm) {
    const { type, props } = vdom
    const renderVdom = type.type(props)
    vdom.oldRenderVdom = renderVdom
    return createDOM(renderVdom)
}

function updateElement(oldVdom, newVdom) {
    if (oldVdom.type.$$typeof === REACT_MEMO) {
        updateMemoComponent(oldVdom, newVdom)
    }
}

function updateMemoComponent(oldVdom, newVdom) {
    const { type } = oldVdom
    if (!type.compare(oldVdom.props, newVdom.props)) {
        // 如果不一样则更新渲染
        const oldDOM = findDOM(oldVdom)
        const parentDOM = oldDOM.parentNode
        const { type, props } = newVdom
        const renderVdom = type.type(props)
        compareTwoVdom(parentDOM, oldVdom.oldRenderVdom, renderVdom)
        newVdom.oldRenderVdom = renderVdom
    } else {
        // 否则用旧的值
        newVdom.oldRenderVdom = oldVdom.oldRenderVdom
    }
}
```

## createPortal

src/react-dom

```js
const ReactDOM = {
    render,
    createPortal: render
}

export default ReactDOM
```

注意，这样写，上面的 mountXXXComponent 里得判断 renderVdom 为空时，返回 null

## hooks



### useState

+ 每次渲染保留 state
+ 返回一对值，当前状态和设置状态的函数，但不会像 this.setState 一样能合并状态

src/react-dom

```js
const hookStates = [] // 存放状态的数组，原版是链表
let hookIndex = 0 // 存放索引的值
let scheduleUpdate

export function useState(initialState) {
    hookStates[hookIndex] = hookStates[hookIndex] || initialState
    const currentIndex = hookIndex

    function setState(newState) {
        hookStates[currentIndex] = newState
        scheduleUpdate()
    }
    return [hookStates[hookIndex++], setState]
}


function render(vdom, container) {
    mount(vdom, container)
    scheduleUpdate = () => { 
        // React 每次更新都是从根节点开始更新，因为它不知道新的状态会影响哪些组件
        // 在真正的源码里，类组件也是从根节点开始渲染（dom-diff）的
        // 批量调度跟 vue 的 nextTick 更新机制一样
        // 新版调度有优先级，新版每个组件都有一个 fiber hookState 和 hookIndex
        hookIndex = 0
        compareTwoVdom(container, vdom, vdom)
    }
}
```

src/react

```js
import * as hooks from './react-dom'

const React = {
    ...hooks
}
export default React
```

### useCallback useMemo

useCallback 依赖性发生改变的时候才更新函数

src/react-dom

```js
export function useCallback() {
    if (hookState[hookIndex]) { // 不是第一次的情况
        const [lastCallback, lastDeps] = hookState[hookIndex]
        const same = deps.every((item, index) => item === lastDeps[index])
        if (same) {
            hookIndex ++
            return lastCallback
        } else {
            hookState[hookIndex ++] = [callback, deps]
            return callback
        }
    } else { // 第一次渲染，到这里
        hookState[hookIndex ++] = [callback, deps]
        return callback
    }
}

export function useMemo(factory, deps) {
    if (hookState[hookIndex]) { // 不是第一次的情况
        const [lastMemo, lastDeps] = hookState[hookIndex]
        const same = deps.every((item, index) => item === lastDeps[index])
        if (same) {
            hookIndex ++
            return lastMemo
        } else {
            const newMemo = factory()
            hookState[hookIndex ++] = [newMemo, deps]
            return newMemo
        }
    } else { // 第一次渲染，到这里
        const newMemo = factory()
        hookState[hookIndex ++] = [newMemo, deps]
        return newMemo
    }
}
```

### useReducer

useState 的替代方案，并返回当前的 state 极其配套的 dispatch 方法

src/react-dom

```js
export function useReducer(reducer, initialState) {
    hookStates[hookIndex] = hookStates[hookIndex] || (typeof initialState === 'function' ? initialState() : initialState)
    const currentIndex = hookIndex

    function dispatch(action) {
        const oldState = hookStates[currentIndex]
        if (typeof reducer === 'function') {
            const newState = reducer(oldState, action)
            hookStates[currentIndex] = newState
        } else {
            const newState = typeof action === 'function' ? action(oldState) : action
            hookStates[currentIndex] = action
        }
        scheduleUpdate()
    }
    return [hookStates[hookIndex++], dispatch]
}

// function useState(initialState) { return useReducer(null, initialState) }
```

### useContext

src/react-dom

```js
export function useContext(context) {
    return context._currentValue
}
```

### useEffect

是纯函数世界到命令式世界的逃生通道

src/react-dom

```js
export function useEffect(callback, deps) {
    const currentIndex = hookIndex
    if (hookStates[hookIndex]) {
        const [destory, lastDeps] = hookStates[hookIndex]
        const same = deps && deps.every((item, index) => item === lastDeps[index])
        if (same) {
            hookIndex ++
        } else {
            setTimeout(() => {
                if (destory) destory()
                hookStates[currentIndex] = [callback(), deps]
            })
            hookIndex ++
        }
    } else { // 第一次
        setTimeout(() => {
            hookStates[currentIndex] = [callback(), deps]
        })
        hookIndex ++
    }
}
```

### useLayoutEffect

区别是它是微任务

src/react-dom

```js
export function useLayoutEffect(callback, deps) {
    const currentIndex = hookIndex
    if (hookStates[hookIndex]) {
        const [destory, lastDeps] = hookStates[hookIndex]
        const same = deps && deps.every((item, index) => item === lastDeps[index])
        if (same) {
            hookIndex ++
        } else {
            queueMicrotask(() => {
                if (destory) destory()
                hookStates[currentIndex] = [callback(), deps]
            })
            hookIndex ++
        }
    } else { // 第一次
        queueMicrotask(() => {
            hookStates[currentIndex] = [callback(), deps]
        })
        hookIndex ++
    }
}
```

### useRef

src/react-dom

```js
export function useRef(initialValue) {
    hookStates[hookIndex] = hookStates[hookIndex] || { current: initialValue }
    return hookStates[hookIndex ++]
}
```

### useImperativeHandle forwardRef

src/react

```js
export function forwardRef() {
    // 见上面逻辑
}

const React = {
    forwardRef
}

export default React
```

src/react-dom

```js
export function useImperativeHandle(ref, factory) {
    ref.current = factory()
}
```


## fiber