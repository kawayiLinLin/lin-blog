---
title: React 全家桶
date: 2022-07-24 13:59:37
tags:
---

## 起步

脚手架生成的代码入口js文件，稍微修改一下
src/index.js
```js
import React from 'react'
import ReactDOM from 'react-dom/client'

const root = ReactDOM.createRoot(document.getElementBy('root'))
root.render(<h1 children="app" />)
```

jsx 会被 babel 转换成 React.createElement 函数调用，它返回的对象就是虚拟DOM

要禁用React17以上的新版的 jsx 转换，可以在命令前加入环境变量 `start: cross-env DISABLED_NEW_JSX_TRANSFORM=true react-scripts start`，新版 `import jsx from 'jsx'; jsx(xxx)`

## 实现 React.createElement

src/utils.js

```js
import { REACT_TEXT } from './element'
// 为了简化实现，所以加了这个逻辑，源码没有，把普通的数字和字符串包装成元素
export function wrapToVdom(element) {
    return typeof element === 'string' || typeof element === 'number' ? {
        type: REACT_TEXT,
        props: element
    } : element
}
```

src/element.js 元素类型

```js
// react 元素
export const REACT_ELEMENT = Symbol('react.element')
// 
export const REACT_TEXT = Symbol('react.text')
```

src/react.js

```js
import { REACT_ELEMENT } from './element'
import { wrapToVdom } from './utils'

function createElement(type, config, children) {
    let ref // 获取真实dom的
    let key // 用来实现 dom diff 的
    if (config) {
        delete config.__source
        delete config.__self
        ref = config.ref
        delete config.ref
        key = config.key
        delete config.key
    }

    const props = { ...config }
    if (arguments.length > 3) {
        // 如果有多个儿子
        props.children = Array.prototype.slice.call(argument, 2).map(wrapToVdom)
    } else {
        // 如果只有一个儿子
        props.children = mapToVdom(children)
    }
    return {
        $$typeof: REACT_ELEMENT, // 表示这是一个虚拟dom，一个React元素
        type, // 虚拟dom的元素类型
        ref,
        key,
        props // id className style
    }
}


const React = {
    createElement,
}

export default React
```

## 渲染

这里还是使用 `ReactDOM.render(<App />, root)`

React16核心设计思路已经齐了
React17加入了fiber
React18加入concurrent优先级调度并发执行，1718为了优化性能

src/react-dom.js

```js
// 需要把虚拟dom变成真实dom变到容器中
function render(vdom, container) {
    mount(vdom, container)
}

function mount(vdom, container) {
    const newDOM = createDOM(vdom)
    container.appendChild(newDOM)
}

function createDOM(vdom) {
    let { type, props } = vdom
    let dom
    if (type === REACT_TEXT) {
        dom = document.createTextNode(props)
    } else {
        dom = document.createTextNode(type)
    }
    if (props) {
        // 更新属性
        updateProps(dom, {} /* 老属性 */, props /* 新属性 */ )
        // 渲染儿子
        if (typeof props.children === 'object' && props.children.props) {
            // 独生子
            mount(props.children, dom)
        } else if (Array.isArray(props.children)) {
            reconcileChildren(props.children, dom)
        }
    }
    return dom
}

function updateProps(dom, oldProps = {}, newProps = {}) {
    for (let key in newProps) {
        if (key === 'children') continue
        else if (key === 'style') {
            const styleObj = newProps[key]
            for (let attr in styleObj) {
                dom.style[attr] = styleObj[attr]
            }
        } else {
            dom[key] = newProps[key]
        }
    }

    for (let key in oldProps) {
        if (!newProps.hasOwnProperty(key)) {
            dom[key] = null
        }
    }
}

// 遍历子元素然后渲染
function reconcileChildren(children, parentDOM) {
    for (let i < 0; i < children.length; i++) {
        mount(children[i], parentDOM)
    }
}

const ReactDOM = {
    render
}

export default ReactDOM
```

## fiber